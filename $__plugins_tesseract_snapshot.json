[
    {
        "text": "{\n    \"tiddlers\": {\n        \"$:/core/ui/ControlPanel/Saving/Snapshot\": {\n            \"text\": \"| <$link to=\\\"$:/config/Snapshot/BackupLocation\\\">Backup Location</$link>|<$edit-text tiddler=\\\"$:/config/Snapshot/BackupLocation\\\" default=\\\"\\\" tag=\\\"input\\\"/>|\\n| <$link to=\\\"$:/config/Snapshot/SuffixFormat\\\">Suffix Format</$link>|<$edit-text tiddler=\\\"$:/config/Snapshot/SuffixFormat\\\" default=\\\"\\\" tag=\\\"input\\\"/>|\\n\\n\",\n            \"title\": \"$:/core/ui/ControlPanel/Saving/Snapshot\",\n            \"tags\": \"$:/tags/ControlPanel/Saving\",\n            \"modified\": \"20180824070405084\",\n            \"created\": \"20180824055743178\",\n            \"caption\": \"Snapshot\"\n        },\n        \"$:/core/modules/savers/tiddlyfoxBackup.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/savers/tiddlyBackup.js\\ntype: application/javascript\\nmodule-type: saver\\n\\nHandles saving changes via the TiddlyFox file extension\\n\\n\\\\*/\\n(function() {\\n\\n    /*jslint node: true, browser: true */\\n    /*global $tw: false, netscape: false, Components: false */\\n    \\\"use strict\\\";\\n\\n    var TiddlyBackup = function(wiki) {};\\n\\n    TiddlyBackup.prototype.save = function(text, method, callback) {\\n        var messageBox = document.getElementById(\\\"tiddlyfox-message-box\\\");\\n        if (messageBox) {\\n            // Get the pathname of this document\\n            var windowlocation = document.location.toString().split(\\\"#\\\")[0];\\n            var backuplocation = $tw.wiki.getTiddlerText(\\\"$:/config/Snapshot/BackupLocation\\\");\\n            var filename = window.location.pathname.split(\\\"/\\\").slice(-1)[0];\\n            var pathname;\\n            if (typeof backuplocation !== \\\"undefined\\\" && backuplocation !== \\\"\\\") {\\n                if (backuplocation.substr(-1) != '/') backuplocation += '/';\\n                pathname = backuplocation + filename;\\n            } else {\\n                pathname = windowlocation;\\n                // Replace file://localhost/ with file:///\\n                if (pathname.indexOf(\\\"file://localhost/\\\") === 0) {\\n                    pathname = \\\"file://\\\" + pathname.substr(16);\\n                }\\n                // Windows path file:///x:/blah/blah --> x:\\\\blah\\\\blah\\n                if (/^file\\\\:\\\\/\\\\/\\\\/[A-Z]\\\\:\\\\//i.test(pathname)) {\\n                    // Remove the leading slash and convert slashes to backslashes\\n                    pathname = pathname.substr(8).replace(/\\\\//g, \\\"\\\\\\\\\\\");\\n                    // Firefox Windows network path file://///server/share/blah/blah --> //server/share/blah/blah\\n                } else if (pathname.indexOf(\\\"file://///\\\") === 0) {\\n                    pathname = \\\"\\\\\\\\\\\\\\\\\\\" + unescape(pathname.substr(10)).replace(/\\\\//g, \\\"\\\\\\\\\\\");\\n                    // Mac/Unix local path file:///path/path --> /path/path\\n                } else if (pathname.indexOf(\\\"file:///\\\") === 0) {\\n                    pathname = unescape(pathname.substr(7));\\n                    // Mac/Unix local path file:/path/path --> /path/path\\n                } else if (pathname.indexOf(\\\"file:/\\\") === 0) {\\n                    pathname = unescape(pathname.substr(5));\\n                    // Otherwise Windows networth path file://server/share/path/path --> \\\\\\\\server\\\\share\\\\path\\\\path\\n                } else {\\n                    pathname = \\\"\\\\\\\\\\\\\\\\\\\" + unescape(pathname.substr(7)).replace(new RegExp(\\\"/\\\", \\\"g\\\"), \\\"\\\\\\\\\\\");\\n                }\\n            }\\n            // Create the message element and put it in the message box\\n            var message = document.createElement(\\\"div\\\");\\n\\n            var df = $tw.utils.formatDateString(new Date(), $tw.wiki.getTiddlerText(\\\"$:/config/Snapshot/SuffixFormat\\\") || \\\"0DD-0MM-YYYY--0hh-0mm-0ss\\\");\\n            pathname = pathname.substring(0, pathname.lastIndexOf(\\\".\\\")) + '--' + df + pathname.substring(pathname.lastIndexOf(\\\".\\\"));\\n            message.setAttribute(\\\"data-tiddlyfox-path\\\", decodeURIComponent(pathname));\\n            message.setAttribute(\\\"data-tiddlyfox-content\\\", text);\\n            messageBox.appendChild(message);\\n            // Add an event handler for when the file has been saved\\n            message.addEventListener(\\\"tiddlyfox-have-saved-file\\\", function(event) {\\n                callback(null);\\n            }, false);\\n            // Create and dispatch the custom event to the extension\\n            var event = document.createEvent(\\\"Events\\\");\\n            event.initEvent(\\\"tiddlyfox-save-file\\\", true, false);\\n            message.dispatchEvent(event);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    };\\n\\n    /*\\n    Information about this saver\\n    */\\n    TiddlyBackup.prototype.info = {\\n        name: \\\"tiddlyfox\\\",\\n        priority: 1500,\\n        capabilities: [\\\"backup\\\"]\\n    };\\n\\n    /*\\n    Static method that returns true if this saver is capable of working\\n    */\\n    exports.canSave = function(wiki) {\\n        return true;\\n    };\\n\\n    /*\\n    Create an instance of this saver\\n    */\\n    exports.create = function(wiki) {\\n        return new TiddlyBackup(wiki);\\n    };\\n\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/core/modules/savers/tiddlyfoxBackup.js\",\n            \"tags\": \"\",\n            \"module-type\": \"saver\",\n            \"modified\": \"20180824090829771\",\n            \"created\": \"20180820110234866\"\n        },\n        \"$:/core/modules/saver-handler.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/saver-handler.js\\ntype: application/javascript\\nmodule-type: global\\n\\nThe saver handler tracks changes to the store and handles saving the entire wiki via saver modules.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*\\nInstantiate the saver handler with the following options:\\nwiki: wiki to be synced\\ndirtyTracking: true if dirty tracking should be performed\\n*/\\nfunction SaverHandler(options) {\\n\\tvar self = this;\\n\\tthis.wiki = options.wiki;\\n\\tthis.dirtyTracking = options.dirtyTracking;\\n\\tthis.pendingAutoSave = false;\\n\\t// Make a logger\\n\\tthis.logger = new $tw.utils.Logger(\\\"saver-handler\\\");\\n\\t// Initialise our savers\\n\\tif($tw.browser) {\\n\\t\\tthis.initSavers();\\n\\t}\\n\\t// Only do dirty tracking if required\\n\\tif($tw.browser && this.dirtyTracking) {\\n\\t\\t// Compile the dirty tiddler filter\\n\\t\\tthis.filterFn = this.wiki.compileFilter(this.wiki.getTiddlerText(this.titleSyncFilter));\\n\\t\\t// Count of changes that have not yet been saved\\n\\t\\tthis.numChanges = 0;\\n\\t\\t// Listen out for changes to tiddlers\\n\\t\\tthis.wiki.addEventListener(\\\"change\\\",function(changes) {\\n\\t\\t\\t// Filter the changes so that we only count changes to tiddlers that we care about\\n\\t\\t\\tvar filteredChanges = self.filterFn.call(self.wiki,function(iterator) {\\n\\t\\t\\t\\t$tw.utils.each(changes,function(change,title) {\\n\\t\\t\\t\\t\\tvar tiddler = self.wiki.getTiddler(title);\\n\\t\\t\\t\\t\\titerator(tiddler,title);\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t\\t// Adjust the number of changes\\n\\t\\t\\tself.numChanges += filteredChanges.length;\\n\\t\\t\\tself.updateDirtyStatus();\\n\\t\\t\\t// Do any autosave if one is pending and there's no more change events\\n\\t\\t\\tif(self.pendingAutoSave && self.wiki.getSizeOfTiddlerEventQueue() === 0) {\\n\\t\\t\\t\\t// Check if we're dirty\\n\\t\\t\\t\\tif(self.numChanges > 0) {\\n\\t\\t\\t\\t\\tself.saveWiki({\\n\\t\\t\\t\\t\\t\\tmethod: \\\"autosave\\\",\\n\\t\\t\\t\\t\\t\\tdownloadType: \\\"text/plain\\\"\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tself.pendingAutoSave = false;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Listen for the autosave event\\n\\t\\t$tw.rootWidget.addEventListener(\\\"tm-auto-save-wiki\\\",function(event) {\\n\\t\\t\\t// Do the autosave unless there are outstanding tiddler change events\\n\\t\\t\\tif(self.wiki.getSizeOfTiddlerEventQueue() === 0) {\\n\\t\\t\\t\\t// Check if we're dirty\\n\\t\\t\\t\\tif(self.numChanges > 0) {\\n\\t\\t\\t\\t\\tself.saveWiki({\\n\\t\\t\\t\\t\\t\\tmethod: \\\"autosave\\\",\\n\\t\\t\\t\\t\\t\\tdownloadType: \\\"text/plain\\\"\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Otherwise put ourselves in the \\\"pending autosave\\\" state and wait for the change event before we do the autosave\\n\\t\\t\\t\\tself.pendingAutoSave = true;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Set up our beforeunload handler\\n\\t\\t$tw.addUnloadTask(function(event) {\\n\\t\\t\\tvar confirmationMessage;\\n\\t\\t\\tif(self.isDirty()) {\\n\\t\\t\\t\\tconfirmationMessage = $tw.language.getString(\\\"UnsavedChangesWarning\\\");\\n\\t\\t\\t\\tevent.returnValue = confirmationMessage; // Gecko\\n\\t\\t\\t}\\n\\t\\t\\treturn confirmationMessage;\\n\\t\\t});\\n\\t}\\n\\t// Install the save action handlers\\n\\tif($tw.browser) {\\n\\t\\t$tw.rootWidget.addEventListener(\\\"tm-save-wiki\\\",function(event) {\\n\\t\\t\\tself.saveWiki({\\n\\t\\t\\t\\ttemplate: event.param,\\n\\t\\t\\t\\tdownloadType: \\\"text/plain\\\",\\n\\t\\t\\t\\tvariables: event.paramObject\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\t$tw.rootWidget.addEventListener(\\\"tm-download-file\\\",function(event) {\\n\\t\\t\\tself.saveWiki({\\n\\t\\t\\t\\tmethod: \\\"download\\\",\\n\\t\\t\\t\\ttemplate: event.param,\\n\\t\\t\\t\\tdownloadType: \\\"text/plain\\\",\\n\\t\\t\\t\\tvariables: event.paramObject\\n\\t\\t\\t});\\n\\t\\t});\\n              $tw.rootWidget.addEventListener(\\\"tm-backup-wiki\\\",function(event) {\\n\\t\\t\\tself.saveWiki({\\n\\t\\t\\t\\tmethod: \\\"backup\\\",\\n\\t\\t\\t\\ttemplate: event.param,\\n\\t\\t\\t\\tdownloadType: \\\"text/plain\\\",\\n\\t\\t\\t\\tvariables: event.paramObject\\n\\t\\t\\t});\\n\\t\\t});\\n\\t}\\n}\\n\\nSaverHandler.prototype.titleSyncFilter = \\\"$:/config/SaverFilter\\\";\\nSaverHandler.prototype.titleAutoSave = \\\"$:/config/AutoSave\\\";\\nSaverHandler.prototype.titleSavedNotification = \\\"$:/language/Notifications/Save/Done\\\";\\n\\n/*\\nSelect the appropriate saver modules and set them up\\n*/\\nSaverHandler.prototype.initSavers = function(moduleType) {\\n\\tmoduleType = moduleType || \\\"saver\\\";\\n\\t// Instantiate the available savers\\n\\tthis.savers = [];\\n\\tvar self = this;\\n\\t$tw.modules.forEachModuleOfType(moduleType,function(title,module) {\\n\\t\\tif(module.canSave(self)) {\\n\\t\\t\\tself.savers.push(module.create(self.wiki));\\n\\t\\t}\\n\\t});\\n\\t// Sort the savers into priority order\\n\\tthis.savers.sort(function(a,b) {\\n\\t\\tif(a.info.priority < b.info.priority) {\\n\\t\\t\\treturn -1;\\n\\t\\t} else {\\n\\t\\t\\tif(a.info.priority > b.info.priority) {\\n\\t\\t\\t\\treturn +1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n/*\\nSave the wiki contents. Options are:\\n\\tmethod: \\\"save\\\", \\\"autosave\\\" or \\\"download\\\"\\n\\ttemplate: the tiddler containing the template to save\\n\\tdownloadType: the content type for the saved file\\n*/\\nSaverHandler.prototype.saveWiki = function(options) {\\n\\toptions = options || {};\\n\\tvar self = this,\\n\\t\\tmethod = options.method || \\\"save\\\",\\n\\t\\tvariables = options.variables || {},\\n\\t\\ttemplate = options.template || \\\"$:/core/save/all\\\",\\n\\t\\tdownloadType = options.downloadType || \\\"text/plain\\\",\\n\\t\\ttext = this.wiki.renderTiddler(downloadType,template,options),\\n\\t\\tcallback = function(err) {\\n\\t\\t\\tif(err) {\\n\\t\\t\\t\\talert($tw.language.getString(\\\"Error/WhileSaving\\\") + \\\":\\\\n\\\\n\\\" + err);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Clear the task queue if we're saving (rather than downloading)\\n\\t\\t\\t\\tif(method !== \\\"download\\\") {\\n\\t\\t\\t\\t\\tself.numChanges = 0;\\n\\t\\t\\t\\t\\tself.updateDirtyStatus();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$tw.notifier.display(self.titleSavedNotification);\\n\\t\\t\\t\\tif(options.callback) {\\n\\t\\t\\t\\t\\toptions.callback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t// Ignore autosave if disabled\\n\\tif(method === \\\"autosave\\\" && this.wiki.getTiddlerText(this.titleAutoSave,\\\"yes\\\") !== \\\"yes\\\") {\\n\\t\\treturn false;\\n\\t}\\n\\t// Call the highest priority saver that supports this method\\n\\tfor(var t=this.savers.length-1; t>=0; t--) {\\n\\t\\tvar saver = this.savers[t];\\n\\t\\tif(saver.info.capabilities.indexOf(method) !== -1 && saver.save(text,method,callback,{variables: {filename: variables.filename}})) {\\n\\t\\t\\tthis.logger.log(\\\"Saving wiki with method\\\",method,\\\"through saver\\\",saver.info.name);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n};\\n\\n/*\\nChecks whether the wiki is dirty (ie the window shouldn't be closed)\\n*/\\nSaverHandler.prototype.isDirty = function() {\\n\\treturn this.numChanges > 0;\\n};\\n\\n/*\\nUpdate the document body with the class \\\"tc-dirty\\\" if the wiki has unsaved/unsynced changes\\n*/\\nSaverHandler.prototype.updateDirtyStatus = function() {\\n\\tif($tw.browser) {\\n\\t\\t$tw.utils.toggleClass(document.body,\\\"tc-dirty\\\",this.isDirty());\\n\\t}\\n};\\n\\nexports.SaverHandler = SaverHandler;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/core/modules/saver-handler.js\",\n            \"revision\": \"0\",\n            \"module-type\": \"global\",\n            \"modified\": \"20180824092010979\",\n            \"created\": \"20180820104549261\",\n            \"bag\": \"default\"\n        },\n        \"$:/plugins/tesseract/snapshot/readme\": {\n            \"created\": \"20180824091715150\",\n            \"text\": \"Provides a new message ''tm-backup-wiki'' which can be triggered by button widget/any message triggering widget. Once triggered, it will save a snapshot of the wiki with a timestamp in the format `0DD-0MM-YYYY--0hh-0mm-0ss` to the same location as the original file. The default location and timestamp format can be changed under Control Panel>Saving>Snapshot. Timestamps respect the format of `now` macro. \\n\\nAnd my wife hates me for it.\",\n            \"title\": \"$:/plugins/tesseract/snapshot/readme\",\n            \"tags\": \"\",\n            \"modified\": \"20180824092936282\"\n        }\n    }\n}",
        "version": "1.0.3",
        "type": "application/json",
        "title": "$:/plugins/tesseract/snapshot",
        "plugin-type": "plugin",
        "modified": "20180824091558164",
        "list": "readme",
        "description": "Snapshot: Timestamped backups",
        "created": "20180824091547423",
        "core-version": "5.1.16",
        "author": "Riz"
    }
]